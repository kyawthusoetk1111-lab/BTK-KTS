/**
 * Core Philosophy: This ruleset enforces a strict, multi-tiered security model.
 * A core principle is path-based ownership, where a user's private data is stored in a hierarchical
 * structure under their unique user ID. For globally accessible data like quizzes, security is managed
 * via a denormalized `ownerId` field within the document itself, ensuring users can only write to their
 * own records while allowing broad read access for students.
 *
 * Data Structure:
 * - /users/{userId}/... : Private user data and exam results are nested here.
 * - /quizzes/{quizId}/... : Quizzes are in a top-level collection to allow for easy listing by all users.
 * - /passages/{passageId}/... : A top-level collection for public, read-only content.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access must be explicitly granted.
 * - Ownership via `ownerId`: Write access to quizzes and their sub-collections is controlled by an `ownerId`
 *   field in the document data, which must match the authenticated user's UID.
 * - Public Quiz Listing: The top-level `/quizzes` collection is readable by any authenticated user,
 *   enabling students to browse and take any available quiz.
 * - No User Listing: The rules do not allow for querying the top-level `/users` collection, preventing
 *   the exposure of the user base.
 * - Secure Result Handling: Exam results are stored in a subcollection under the user, e.g.,
 *   `/users/{userId}/examResults/{examResultId}`. This path-based ownership guarantees that
 *   users can only read, write, and query their own results.
 *
 * Denormalization for Authorization:
 * To ensure high-performance and secure authorization without using expensive `get()` calls in rules,
 * this ruleset relies on denormalization.
 * - `ownerId` Field: Instead of checking a parent document, rules check an `ownerId` field directly
 *   on the document being written to.
 *
 * Structural Segregation:
 * The data model separates private user data (`/users/{userId}`) from shared quiz data (`/quizzes`) and
 * public content (`/passages`). This segregation simplifies rules, improves query performance, and enhances
 * security by preventing accidental cross-collection data exposure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the core of our ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the user has an 'admin' role.
     * This requires a get() call, so it should be used sparingly, primarily for admin-only write operations.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType == 'admin';
    }

    /**
     * Checks if the user is a teacher or an admin.
     */
    function isTeacherOrAdmin() {
      let userRole = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType;
      return isSignedIn() && (userRole == 'teacher' || userRole == 'admin');
    }

    /**
     * Checks if a field is immutable during an update operation.
     * Prevents clients from changing critical relational keys like owner IDs.
     */
    function isImmutable(field) {
        return request.resource.data[field] == resource.data[field];
    }

    // -------------------------------------------------------------------------
    // System Status Rules
    // -------------------------------------------------------------------------
    match /system/{docId} {
      allow get: if true;
      allow write: if isAdmin();
    }
    
    // -------------------------------------------------------------------------
    // User Data Rules
    // -------------------------------------------------------------------------

    /**
     * @description Users can create their own profile and can only read or write their own data.
     * Admins are allowed to update user profiles (e.g. for upgrading tiers).
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && request.resource.data.id == resource.data.id || isAdmin();
      allow delete: if isOwner(userId) || isAdmin();

       /**
       * @description Exam results are private to the user. Path-based ownership.
       * @path /users/{userId}/examResults/{examResultId}
       */
      match /examResults/{examResultId} {
        allow read, write: if isOwner(userId);
      }
      
      /**
       * @description A user can read their own purchases. Purchases are created by admins.
       * @path /users/{userId}/purchases/{purchaseId}
       */
      match /purchases/{purchaseId} {
        allow get, list: if isOwner(userId);
        allow create, update, delete: if isAdmin();
      }
    }
    
    // -------------------------------------------------------------------------
    // Quiz Rules (Top-level collection)
    // -------------------------------------------------------------------------

    /**
     * @description Quizzes are public to read for any signed-in user, but writable only by the owner.
     * @path /quizzes/{quizId}
     */
    match /quizzes/{quizId} {
      allow get, list: if isSignedIn();
      allow create: if isOwner(request.resource.data.ownerId);
      allow update, delete: if isOwner(resource.data.ownerId);

      /**
       * @description Sections are public to read, but writable only by the quiz owner.
       * Ownership is determined by checking the ownerId of the quiz document being written to.
       * A `get()` call is used here as it's a necessary check for writes to a subcollection
       * when ownership is based on the parent document.
       */
      match /sections/{sectionId} {
        allow get, list: if isSignedIn();
        allow write: if get(/databases/$(database)/documents/quizzes/$(quizId)).data.ownerId == request.auth.uid;

        /**
         * @description Questions follow the same pattern as sections.
         */
        match /questions/{questionId} {
          allow get, list: if isSignedIn();
          allow write: if get(/databases/$(database)/documents/quizzes/$(quizId)).data.ownerId == request.auth.uid;

          /**
           * @description Answer options follow the same pattern.
           */
          match /answerOptions/{answerOptionId} {
            allow get, list: if isSignedIn();
            allow write: if get(/databases/$(database)/documents/quizzes/$(quizId)).data.ownerId == request.auth.uid;
          }

          /**
           * @description Matching pairs follow the same pattern.
           */
          match /matching/{matchingId} {
            allow get, list: if isSignedIn();
            allow write: if get(/databases/$(database)/documents/quizzes/$(quizId)).data.ownerId == request.auth.uid;
          }
        }
      }
    }

    // -------------------------------------------------------------------------
    // Public Content Rules
    // -------------------------------------------------------------------------

    /**
     * @description Passages are public, read-only content. Anyone can view them.
     * @path /passages/{passageId}
     */
    match /passages/{passageId} {
      allow get, list: if true;
      allow write: if false; // TODO: Implement admin or teacher role for writes.

      /**
       * @description Passage questions are public and read-only.
       * @path /passages/{passageId}/passageQuestions/{passageQuestionId}
       */
      match /passageQuestions/{passageQuestionId} {
        allow get, list: if true;
        allow write: if false; // TODO: Implement admin or teacher role for writes.
      }
    }
    
    // -------------------------------------------------------------------------
    // Monetization and Expenditure Rules
    // -------------------------------------------------------------------------

    /**
     * @description Users can create their own payment records. Admins can read/update all payment records for verification.
     * @path /payments/{paymentId}
     */
    match /payments/{paymentId} {
        allow get, list: if isAdmin();
        allow create: if isSignedIn() && request.auth.uid == request.resource.data.userId;
        allow update: if isAdmin();
        allow delete: if isAdmin();
    }
    
    /**
     * @description Admins can manage all business expenditures.
     * @path /expenditures/{expenditureId}
     */
    match /expenditures/{expenditureId} {
        allow read, write: if isAdmin();
    }

    // -------------------------------------------------------------------------
    // Quiz Bank Rules
    // -------------------------------------------------------------------------
    match /quizBank/{questionId} {
      allow read: if isTeacherOrAdmin();
      allow create: if isTeacherOrAdmin() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isTeacherOrAdmin() && (resource.data.ownerId == request.auth.uid || isAdmin());
    }
  }
}
